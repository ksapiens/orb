
#require 'rubygems'
require 'sequel'
require 'logger'
require 'shellwords'
require 'digest/md5.so'
#require 'profile'
#p __FILE___
#MAX_SIZE = 15
#MIN_SIZE = 4
#THREADS = 4

DB = Sequel.sqlite 'db.sqlite'
#DB.loggers << Logger.new("tagger.log")

LOG = Logger.new("unite.log")
#LOG = Logger.new($stdout)
#FILTER = (File.open 'stopwords/all', 'r').read.split "\n"

DB.create_table( :tags ) do 
  primary_key :id
  foreign_key :field_id
  Symbol :name
  Integer :count
end unless DB.table_exists? :tags

DB.create_table( :fields ) do 
  primary_key :id
  String :name
end unless DB.table_exists? :fields

DB.create_table( :items ) do
  primary_key :id
  String :path#, :unique => true 
  String :md5, :size => 32 
  String :mimetype, :size => 12
#  String :tags
  Integer :size
end unless DB.table_exists? :items
 
DB.create_table( :taggings ) do
  primary_key :id
  foreign_key :supported_id, :tags#, :on_delete => :cascade
  foreign_key :available_id, :tags#, :on_delete => :cascade
end unless DB.table_exists? :taggings

class Item < Sequel::Model
  def self.tagged tags
    self.where( tags.map{|t| Sequel.like((t[0]=="#" ? :mimetype : :path), "%"+t.delete("#")+"%") } )
  end
end
class Tagging < Sequel::Model
end
class Tag < Sequel::Model
  many_to_one :field
  many_to_many :availables, :left_key => :supported_id, :right_key => :available_id, :join_table => :taggings, :class => self
  many_to_many :supporters, :right_key => :supported_id, :left_key => :available_id, :join_table => :taggings, :class => self; end

class Field < Sequel::Model 
  one_to_many :tags; end

class DBManager
  def recurse path, data = {:tags => {}, :files => []}
  #  `file -i #{ path.shellescape }/*`.each_line do |line|
    `file -i #{ (File.absolute_path path).shellescape }/*`.each_line do |line|
  #  open("| file -i #{ (File.absolute_path path).shellescape }/*").read.each_line do |line|
      begin
        next if line[/cannot open/]
        info = line.split(/; charset=|: */) 
        md5 = Digest::MD5.file(info[0]).to_s unless info[1] == "inode/directory"
  #      md5 = `md5sum "#{info[0]}"` unless info[1] == "inode/directory"
  #      md5 = ""
        tags = (info[0].gsub(/\p{^Alpha}/," ").downcase.split.delete_if{|e| e.size<4} + \
                info[1].split("/").map{|m| "#"+m }).map( &:to_sym )
        all = data[:tags]
        tags.each{ |t| 
          all[t] ||= {count: 0, available: []}#; all[t][:count]=0) unless all[t]
          all[t][:count]+=1
          all[t][:available] |= tags - [t] }
#          all[t][:available] = (all[t][:available] || [] | tags - [t] ) }
    #    tags.each { |t| data[:tags] << Tag.new :name => t }
        data[:files] << Item.new( :path=>info[0], :md5=> md5) #unless d 
        recurse info[0], data if info[1] == "inode/directory"
  #      Thread.new{recurse info[0], data} if info[1] == "inode/directory"
      rescue ArgumentError => e 
        LOG.error(line+$!.message)
      end
    end
    p path
    data 
  end

  def index path="."
  #  binding.pry
    DB.transaction do
      data = recurse path
      while Thread.list.count > 1
        puts "files: %s\e[1A" % data[:files].count 
        sleep 0.2
      end
      puts "insert"
      Item.multi_insert data[:files]
  #      p data[:tags].map{ |t,a| Tag.new(:name=>t.to_s) }
      Tag.multi_insert data[:tags].keys.map{|t| Tag.new name: t.to_s, count: data[:tags][t][:count]  }
      tags = Tag.all.map{ |t| [t.name.to_sym, t.id] }.to_h
      Tagging.multi_insert data[:tags].map{ |tag,list| list[:available].map{ |a| Tagging.new( :supported_id => tags[tag], :available_id => tags[a] ) } }.flatten

  #      Tag.multi_insert data[:tags].map{ |t,a| Tag.new(:name=>t) }
    end if File.directory? path
    true
  end

  def search q
    puts Item.tagged(q.split).select_map(:path).join "\n"
  #  for d in Item.where("path like ?", "%"+q+"%").all.map(&:path)
  #    puts "\e[1;33m%s\e[1;34m%s\e[1;33m%s" % [d.partition(/#{q}/)]
  #  end
  #  for d in Keyword.where(:name=>q.lowercase).join(:occurences, :keyword_id=>:id).join(:documents, :id=>:document_id).order(:count).reverse.all
  #    puts "\e[1;32m %s :\e[1;34m %i \e[0m times" % [d.values[:path],d.values[:count]]

  #  end
  end
  
  def cleanup #TODO find duplicates, remove special chars, rename by id3/mime/content
  end

  def rules file="" #TODO visually create rules by wich to sort files
    tags = {}
#    Shoes.app( title: "Create Rules", margin: 10 ) do
#      para "Tags:" + mouse.to_s
#      flow width: 0.5, height: 1.0 do #, margin: 10 do
#        background ghostwhite
#        @p = para
#    end
#      flow width: 0.5, height: 1.0 do #, margin: 10 do
#        background lavender
#        button "Tags:"
#        Tag.select_map(:name).each{ |t| tags[t] = button(t)}#,fill: lightgrey)  }
#      end
#
#      animate 25 do
#        button, left, top = self.mouse
#        @p.replace "mouse: #{button}, #{left}, #{top}"
#      end
  end

  end
  def sort   #TODO move files according to ruleset
  end
  def undo   #TODO undo a batch file operation
  end
  
	#shell tab-completion for tags
  def complete s=""
    LOG.info( $*)
    a = $*[1].split[1..-1] #.shift
    a << "" if $*[1][-1] == " "
    puts public_methods(false).join " " if a.count == 1 

    case a.shift
      when "search"
        puts Tag.where(Sequel.like(:name, a[0]+"%")).select_map(:name).join " " if a.count == 1
        puts Tag[name: a[0]].availables_dataset.select_map(:name).join(" ") if a.count == 2 
#        a.map{|a| Tag[name: a].availables_dataset.select_map :name }
      end
  end

  def help command="help"
    puts <<HELP
    Usage: unite [command] [arguments ...]

    commands:
      index [path]  : recursively index files in [path] 
      search [tags ...] : search for files in filenames and mimetypes

HELP
  end

  def dump table
    #DB[table.to_s]
    #Keyword.all.map{|a| a.db_schema.select{|s| s[:type] == :string } }.join
    #eval table.capitalize + ".all.map(&:name).join"
    #eval "%s.%s" % table
#    puts Hirb::Helpers::AutoTable.render DB[table.to_sym]
  end
