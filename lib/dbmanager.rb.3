
#require 'rubygems'
require 'sequel'
require 'logger'
require 'shellwords'
require 'digest/md5.so'
#require 'profile'
#p __FILE___
#MAX_SIZE = 15
#MIN_SIZE = 4
#THREADS = 4

DB = Sequel.sqlite 'db.sqlite'
#DB.loggers << Logger.new("tagger.log")

DBLOG = Logger.new("unite.log")
#FILTER = (File.open 'stopwords/all', 'r').read.split "\n"

#DB.create_table( :mimes ) do 
#  primary_key :id
#  foreign_key :parent_id :mimes
#  Symbol :name
#  Integer :count
#end unless DB.table_exists? :tags

DB.create_table( :types ) do 
  primary_key :id
  foreign_key :parent_id, :types
  String :name
  Integer :count
end unless DB.table_exists? :types

DB.create_table( :tags ) do 
  primary_key :id
  #foreign_key :field_id
  Symbol :name
  Integer :count
end unless DB.table_exists? :tags

DB.create_table( :items ) do
  primary_key :id
  foreign_key :parent_id, :items
  foreign_key :mime_id, :mimes #, :size => 12
	foreign_key :type_id, :types
  String :path, :unique => true 
  String :md5, :size => 32 
  Integer :size
end unless DB.table_exists? :items
 
DB.create_table( :taggings ) do
  primary_key :id
#  foreign_key :supported_id, :tags#, :on_delete => :cascade
#  foreign_key :available_id, :tags#, :on_delete => :cascade
  foreign_key :tag_id, :tags#, :on_delete => :cascade
  foreign_key :item_id, :items#, :on_delete => :cascade
end unless DB.table_exists? :taggings

class Item < Sequel::Model
  many_to_one :parent, :class => self
  many_to_one :mime
  many_to_one :type
  many_to_many :tags

  def self.tagged tags
    self.where( tags.map{|t| Sequel.like((t[0]=="#" ? :mimetype : :path), "%"+t.delete("#")+"%") } )
  end
end
class Tag < Sequel::Model
  many_to_many :items
end
#class Mime < Sequel::Model
#  one_to_many :items
#end
class Type < Sequel::Model
  one_to_many :items
  many_to_one :parent, :class => self
end

class DBManager

  def recurse path, data = {:types => [], :items => []}
  	directory = Item.new( :path => path )
    `file -i #{ path.shellescape }/*`.each_line do |line|
      begin
        next if line[/cannot open/]
        type, subtype = line[/:(.*);/][2..-2].split "/"
        type = Type.find_or_create :name => type
        subtype = Type.find_or_create :name => subtype
        subtype.parent = type
        
        file = line[/^.*:/][0..-2]
        item = Item.new( :path => file, :md5=> md5)
        item.parent = directory
        
        data[:items] << item 
        data[:types] << [type, subtype]
        
        recurse file, data if subtype == "directory"
  #      Thread.new{recurse info[0], data} if info[1] == "inode/directory"
      rescue ArgumentError => e 
        DBLOG.error(line+$!.message)
      end
    end
    p path
    data 
  end

  def index path="."
  #  binding.pry
  	if File.directory? path
    	DB.transaction do
      	data = recurse File.absolute_path(path)
      	while Thread.list.count > 1
        	puts "files: %s\e[1A" % data[:files].count 
        	sleep 0.2
      	end
      	puts "insert"
      	data[:files] << Item.new( :path => (File.absolute_path path).shellescape )
      	Item.multi_insert data[:files]
  	#      p data[:tags].map{ |t,a| Tag.new(:name=>t.to_s) }
      	
      	Tag.multi_insert data[:tags].keys.map{|t| Tag.new name: t.to_s, count: data[:tags][t][:count]  }
      	
      	tags = Tag.all.map{ |t| [t.name.to_sym, t.id] }.to_h
      	
      	Tagging.multi_insert data[:tags].map{ |tag,list| list[:available].map{ |a| Tagging.new( :supported_id => tags[tag], :available_id => tags[a] ) } }.flatten
	
  	#      Tag.multi_insert data[:tags].map{ |t,a| Tag.new(:name=>t) 
  		end 
  	end
    true
  end

  def search q
    puts Item.tagged(q.split).select_map(:path).join "\n"
  #  for d in Item.where("path like ?", "%"+q+"%").all.map(&:path)
  #    puts "\e[1;33m%s\e[1;34m%s\e[1;33m%s" % [d.partition(/#{q}/)]
  #  end
  #  for d in Keyword.where(:name=>q.lowercase).join(:occurences, :keyword_id=>:id).join(:documents, :id=>:document_id).order(:count).reverse.all
  #    puts "\e[1;32m %s :\e[1;34m %i \e[0m times" % [d.values[:path],d.values[:count]]

  #  end
  end
  
  def cleanup #TODO find duplicates, remove special chars, rename by id3/mime/content
  end

  def rules file="" #TODO visually create rules by wich to sort files
    tags = {}
#    Shoes.app( title: "Create Rules", margin: 10 ) do
#      para "Tags:" + mouse.to_s
#      flow width: 0.5, height: 1.0 do #, margin: 10 do
#        background ghostwhite
#        @p = para
#    end
#      flow width: 0.5, height: 1.0 do #, margin: 10 do
#        background lavender
#        button "Tags:"
#        Tag.select_map(:name).each{ |t| tags[t] = button(t)}#,fill: lightgrey)  }
#      end
#
#      animate 25 do
#        button, left, top = self.mouse
#        @p.replace "mouse: #{button}, #{left}, #{top}"
#      end
  end

  end
  def sort   #TODO move files according to ruleset
  end
  def undo   #TODO undo a batch file operation
  end
  
	#shell tab-completion for tags
  def complete s=""
    DBLOG.info( $*)
    a = $*[1].split[1..-1] #.shift
    a << "" if $*[1][-1] == " "
    puts public_methods(false).join " " if a.count == 1 

    case a.shift
      when "search"
        puts Tag.where(Sequel.like(:name, a[0]+"%")).select_map(:name).join " " if a.count == 1
        puts Tag[name: a[0]].availables_dataset.select_map(:name).join(" ") if a.count == 2 
#        a.map{|a| Tag[name: a].availables_dataset.select_map :name }
      end
  end

  def help command="help"
    puts <<HELP
    Usage: unite [command] [arguments ...]

    commands:
      index [path]  : recursively index files in [path] 
      search [tags ...] : search for files in filenames and mimetypes

HELP
  end

  def dump table
    #DB[table.to_s]
    #Keyword.all.map{|a| a.db_schema.select{|s| s[:type] == :string } }.join
    #eval table.capitalize + ".all.map(&:name).join"
    #eval "%s.%s" % table
#    puts Hirb::Helpers::AutoTable.render DB[table.to_sym]
  end
