#!/usr/bin/env ruby
$LOAD_PATH << "#{File.dirname __FILE__}/lib/"

require 'rubygems'
require 'curses'
require "dbmanager.rb"
require "manparser.rb"
include Curses

module Visual
	attr_accessor :x, :y
	def draw x,y,win
		to_s.draw x,y,color,win
		#UILOG.debug color.to_s
	end	
	def show klass
 		LAYOUT[:main] = klass.new( self )
	end
end	

class Type;	include Visual
	def to_s;	name;	end
	def color; :type; end
	def click; show FileBrowser; end		
	def children; []; end
end
class Item;	include Visual
	def to_s;	path.split("/")[-1]; end	
	def color; COLORS.keys.grep( type.name.to_sym ).first || :item; end
	def click
		case type.name
		when "directory"
			show FileBrowser 
		else
			if executable
				show CMDBuilder
			end
		end
	end
end

class String
	def draw x, y, color, win
		win.setpos y ,x
#		win.attron( color_pair(COLORS.keys.index(color))|A_BOLD )
		win.attron( color_pair(COLORS.keys.index(color)) )
		win.addstr self
	end
end
class Window
#	def child
#		SESSION[SESSION.index(self) + 1]
#	end
#	def prune
#		close
#		child.prune if child
#		SESSION.delete self
#	end
	def click#draw
		refresh
	end
end
class CMDBuilder < Window
	def initialize cmd
		@page = ManPage.new cmd
		m = CONF[:margin]
		menu = LAYOUT[:menu].width
		super lines - 2*m, cols - 2*m, m, menu + m 
	end
	def draw
		@page.options.keys.each_with_index do |option, i|
			option.draw 0, i, COLOR[:default], self
		end
		super
	end
end
class FileBrowser #< Window
	attr_accessor :filter, :choices, :results
	def initialize filter
		w = LAYOUT[:menu].maxx
		m = CONF[:margin]
		@filter = List.new [filter], w+m
		@choices = List.new filter.directories\
			, w+m+2 , @filter.maxy + m #directories
		@results = List.new filter.files\
			, w+m+2 + @choices.maxx+@filter.entries.length #files
		update
	end
	def draw
		@filter.draw
		@choices.draw
		@results.draw
	end
	def update 
		UILOG.debug "filter: %s" % @filter.entries.join("/")
		@choices.entries = @filter[-1].directories
		@results.entries = @filter[-1].files
		@filter.update
		@results.update
		#UILOG.debug "choices: %s" % @choices.inspect
		#UILOG.debug "filter %s" % @filter.height
		@choices.move @filter.maxy + CONF[:margin], @filter.begx + 2
		@choices.update
		@choices.refresh
#		UILOG.debug "x: %s y: %s" % [@choices.maxx,@choices.maxy]
		UILOG.debug "x: %s y: %s" % [@filter.maxx,@filter.maxy]
		
	end
	def click x, y
		s = CONF[:spacing]
		m = CONF[:margin]
		if x > @results.begx
			@results[ (y - m) / s ].click
		else
			if y > @choices.begy
				@filter << @choices[ (y - @filter.maxy - m) / s ]
			else
				@filter.entries = @filter[0..(( y - m ) / s)]
			end
				update
		end
			
	end		
end
class List < Window #Pad
	#include Enumerable
#	attr_accessor :x, :y, :width, :height, :entries
	attr_accessor :entries
	def initialize e=[], x=CONF[:margin],y=CONF[:margin]
		#@x, @y = x, y
		super  0,0, y, x
		keypad = true
		@entries = e #[]
		update #e
		#super  @height, @width, @y, @x
		#refresh
	end	
	def update #entries
		#@entries = entries
		height =  @entries.length * CONF[:spacing]
		width = @entries.max{ |a,b| a.to_s.length <=> b.to_s.length }.to_s.length
		resize height, width
		refresh
	end
	def << (object)
		@entries << object
	end
	def [] (index); @entries[index]; end
	def draw
		return if @entries.empty?
		clear
		box '|', '-'
		@entries.each_with_index do |entry, i|
			entry.draw 0, i * CONF[:spacing], self
			#UILOG.debug "x: %s y: %s" % [curx, cury]
			#entry.draw @x, @y + i * CONF[:FONT_SIZE]
		end
		refresh
	end
	def click x,y
		target = @entries[ (y-begy) / CONF[:spacing] ]
		target.click if target
	end

end
class TextWindow < Window
	attr_reader :text
	def initialize text, align
		super 0, 0, CONF[:margin], MENU.maxx #*MAINRECT
		@text = text
		draw
	end
	def draw
		clear
		box '|', '-'
		text.draw 0, 0, :default, self
		refresh
	end
		
end
#MAINRECT = lines - CONF[:margin], cols - MENU.width-CONF[:margin], CONF[:margin], CONF[:margin]
CONF = { 	:spacing => 2,
				 		:margin => 1 }
UILOG = Logger.new("ui.log")
COLORS = { 	:default =>  [ 100, 100, 100 ],
						:type => 				[ 700, 700, 300 ],
						:executable => 	[ 700, 300, 300 ],
						:item => 				[ 300, 700, 300 ],
						:chardevice => 	[ 300, 700, 700 ],
						:blockdevice =>	[ 700, 300, 700 ],
						#:special 		=>	[ 700, 300, 700 ],
						:directory => 	[ 300, 300, 700 ] }
MENU = List.new ([ Item[:path=>"/home/key/fun"],
										Type[:name=>"plain"] ] )
HELP = TextWindow.new " Welcome, left is the menu ", :center
LAYOUT = { :menu => MENU,
					 :main => HELP }

class SIA # < Window
  def initialize colortest = false
		init_screen
		start_color
		COLORS.each_with_index do |color,i|
			init_color i, *color[1]
			init_pair i, i, 0#COLOR_BLACK
			"#{color[0]} - #{color_content i}".to_s.draw 0,i,color[0],Curses if colortest
		end	
		crmode
		noecho
  	curs_set 0
  	mousemask(ALL_MOUSE_EVENTS)
		stdscr.keypad(true)
  	#mousemask(BUTTON1_CLICKED|BUTTON2_CLICKED|BUTTON3_CLICKED|BUTTON4_CLICKED)
 end
  def draw
		clear
  end
	def run
		loop do
			clear
			refresh
			
			LAYOUT.values.each( &:draw )
    	input = getch #Event.poll 
			refresh  
    	case input
    		when KEY_MOUSE
    			mouse = getmouse
					#UILOG.debug "x: %s y: %s SESSION: %s" % [mouse.x, mouse.y, SESSION.length]
					if mouse.x <= LAYOUT[:menu].maxx + CONF[:margin]
						 LAYOUT[:menu].click mouse.x, mouse.y
					else
						 LAYOUT[:main].click mouse.x, mouse.y
					end	
				#when 27 
				when KEY_EXIT
        	exit
    	end
    end
  end

begin
		SIA.new.run if __FILE__ == $0
	end
ensure
  close_screen
end
